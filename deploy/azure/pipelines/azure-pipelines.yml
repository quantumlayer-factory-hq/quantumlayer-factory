# Azure DevOps Pipeline for QuantumLayer Factory
trigger:
  branches:
    include:
    - main
    - develop
  paths:
    exclude:
    - README.md
    - docs/*

variables:
  # Build variables
  buildConfiguration: 'Release'
  goVersion: '1.21'

  # Azure variables
  azureSubscription: 'QuantumLayer-Production'
  resourceGroupName: 'qlf-prod'
  containerRegistry: 'qlfregistry.azurecr.io'
  aksClusterName: 'qlf-prod-cluster'

  # Image variables
  serverImageRepository: 'qlf/server'
  workerImageRepository: 'qlf/worker'
  frontendImageRepository: 'qlf/frontend'
  imageTag: '$(Build.BuildId)'

  # Helm variables
  helmChart: 'deploy/azure/helm/qlf'

stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: BuildGo
    displayName: 'Build Go Services'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: GoTool@0
      displayName: 'Use Go $(goVersion)'
      inputs:
        version: '$(goVersion)'

    - script: |
        go mod download
        go mod verify
      displayName: 'Download Go modules'

    - script: |
        go test -v ./... -coverprofile=coverage.out
        go tool cover -html=coverage.out -o coverage.html
      displayName: 'Run tests'

    - script: |
        CGO_ENABLED=0 GOOS=linux go build -o $(Build.ArtifactStagingDirectory)/qlf ./cmd/qlf
        CGO_ENABLED=0 GOOS=linux go build -o $(Build.ArtifactStagingDirectory)/worker ./cmd/worker
      displayName: 'Build binaries'

    - publish: $(Build.ArtifactStagingDirectory)
      artifact: go-binaries
      displayName: 'Publish Go binaries'

    - publish: coverage.html
      artifact: test-coverage
      displayName: 'Publish test coverage'

  - job: BuildFrontend
    displayName: 'Build Frontend'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: NodeTool@0
      displayName: 'Use Node.js'
      inputs:
        versionSpec: '18.x'

    - script: |
        cd frontend
        npm ci
        npm run build
      displayName: 'Build frontend'

    - publish: frontend/
      artifact: frontend-build
      displayName: 'Publish frontend build'

- stage: Security
  displayName: 'Security Scanning'
  dependsOn: Build
  jobs:
  - job: SecurityScan
    displayName: 'Security and Vulnerability Scanning'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - download: current
      artifact: go-binaries

    - task: AzureKeyVault@2
      displayName: 'Get secrets from Key Vault'
      inputs:
        azureSubscription: '$(azureSubscription)'
        KeyVaultName: 'qlf-prod-kv'
        SecretsFilter: '*'
        RunAsPreJob: true

    - script: |
        # Install security scanning tools
        curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
      displayName: 'Install security tools'

    - script: |
        # Scan binaries for vulnerabilities
        syft $(Pipeline.Workspace)/go-binaries/qlf -o json > qlf-sbom.json
        grype $(Pipeline.Workspace)/go-binaries/qlf -o json > qlf-vulnerabilities.json

        syft $(Pipeline.Workspace)/go-binaries/worker -o json > worker-sbom.json
        grype $(Pipeline.Workspace)/go-binaries/worker -o json > worker-vulnerabilities.json
      displayName: 'Security scan binaries'

    - publish: .
      artifact: security-reports
      displayName: 'Publish security reports'

- stage: BuildImages
  displayName: 'Build Container Images'
  dependsOn: [Build, Security]
  jobs:
  - job: BuildDockerImages
    displayName: 'Build and Push Docker Images'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - download: current
      artifact: go-binaries
    - download: current
      artifact: frontend-build

    - task: AzureCLI@2
      displayName: 'Login to Azure Container Registry'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az acr login --name $(echo $(containerRegistry) | cut -d'.' -f1)

    - task: Docker@2
      displayName: 'Build and push server image'
      inputs:
        containerRegistry: '$(containerRegistry)'
        repository: '$(serverImageRepository)'
        command: 'buildAndPush'
        Dockerfile: 'deploy/azure/docker/Dockerfile.server'
        buildContext: '.'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Build and push worker image'
      inputs:
        containerRegistry: '$(containerRegistry)'
        repository: '$(workerImageRepository)'
        command: 'buildAndPush'
        Dockerfile: 'deploy/azure/docker/Dockerfile.worker'
        buildContext: '.'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Build and push frontend image'
      inputs:
        containerRegistry: '$(containerRegistry)'
        repository: '$(frontendImageRepository)'
        command: 'buildAndPush'
        Dockerfile: 'deploy/azure/docker/Dockerfile.frontend'
        buildContext: 'frontend'
        tags: |
          $(imageTag)
          latest

- stage: Deploy
  displayName: 'Deploy to Azure'
  dependsOn: BuildImages
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployToProduction
    displayName: 'Deploy to Production AKS'
    environment: 'production'
    pool:
      vmImage: 'ubuntu-latest'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Get AKS credentials'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az aks get-credentials --resource-group $(resourceGroupName) --name $(aksClusterName) --overwrite-existing

          - task: KubernetesManifest@0
            displayName: 'Deploy to AKS'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: 'aks-connection'
              namespace: 'quantumlayer-factory'
              manifests: |
                deploy/azure/k8s/namespace.yaml
                deploy/azure/k8s/qlf-server.yaml
                deploy/azure/k8s/qlf-worker.yaml
                deploy/azure/k8s/temporal.yaml
              containers: |
                $(containerRegistry)/$(serverImageRepository):$(imageTag)
                $(containerRegistry)/$(workerImageRepository):$(imageTag)
                $(containerRegistry)/$(frontendImageRepository):$(imageTag)

          - task: Kubernetes@1
            displayName: 'Wait for rollout'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: 'aks-connection'
              namespace: 'quantumlayer-factory'
              command: 'rollout'
              useConfigurationFile: false
              arguments: 'status deployment/qlf-server --timeout=300s'

          - task: Kubernetes@1
            displayName: 'Check deployment status'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: 'aks-connection'
              namespace: 'quantumlayer-factory'
              command: 'get'
              useConfigurationFile: false
              arguments: 'pods,svc,ingress'

- stage: PostDeploy
  displayName: 'Post Deployment'
  dependsOn: Deploy
  jobs:
  - job: HealthCheck
    displayName: 'Health Check and Monitoring'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      displayName: 'Health check endpoints'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Get external IP
          EXTERNAL_IP=$(kubectl get service -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "External IP: $EXTERNAL_IP"

          # Health check with retry
          for i in {1..5}; do
            if curl -f "http://$EXTERNAL_IP/health"; then
              echo "Health check passed"
              break
            else
              echo "Health check attempt $i failed, retrying in 30s..."
              sleep 30
            fi
          done

    - task: AzureMonitorAlerts@0
      displayName: 'Setup monitoring alerts'
      inputs:
        azureSubscription: '$(azureSubscription)'
        resourceGroupName: '$(resourceGroupName)'

  - job: NotifyTeam
    displayName: 'Notify Team'
    dependsOn: HealthCheck
    steps:
    - task: SlackNotification@1
      displayName: 'Notify Slack'
      inputs:
        SlackApiToken: '$(slackToken)'
        Channel: '#deployments'
        Message: |
          ðŸš€ QuantumLayer Factory deployed successfully!

          **Build**: $(Build.BuildNumber)
          **Environment**: Production
          **Status**: âœ… Healthy

          **Services**:
          - API Server: Ready
          - Worker Nodes: Ready (5 replicas)
          - Temporal: Ready
          - Frontend: Ready

          **Access**: https://api.quantumlayer.dev